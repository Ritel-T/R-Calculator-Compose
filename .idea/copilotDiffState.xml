<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/ritel/calculator/ui/scientific/ScientificScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/ritel/calculator/ui/scientific/ScientificScreen.kt" />
              <option name="originalContent" value="package com.ritel.calculator.ui.scientific&#10;&#10;import androidx.compose.animation.animateColorAsState&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.FastOutLinearInEasing&#10;import androidx.compose.animation.core.FastOutSlowInEasing&#10;import androidx.compose.animation.core.Spring&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.spring&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.horizontalScroll&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.wrapContentSize&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.material3.LocalContentColor&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.DpSize&#10;import androidx.compose.ui.unit.TextUnit&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.ritel.calculator.data.layouts.ButtonGrid&#10;import com.ritel.calculator.data.layouts.ScientificLayoutAlternative&#10;import com.ritel.calculator.data.layouts.ScientificLayoutDefault&#10;import com.ritel.calculator.ui.theme.JetBrainsMono&#10;&#10;@Composable&#10;fun ScientificScreen(modifier: Modifier = Modifier, viewModel: ScientificViewModel = viewModel()) {&#10;    val uiState = viewModel.state&#10;    Column(&#10;        modifier = modifier.fillMaxSize(),&#10;        horizontalAlignment = Alignment.End,&#10;        verticalArrangement = Arrangement.Bottom&#10;    ) {&#10;        ScientificPreviousExpression(&#10;            prevSeq = uiState.prevSeq,&#10;            onClick = viewModel::onPrevSeqClicked,&#10;            modifier = Modifier&#10;                .padding(horizontal = 12.dp, vertical = 12.dp)&#10;                .height(32.dp)&#10;        )&#10;        ScientificInputField(&#10;            sequence = uiState.sequence,&#10;            cursorIndex = uiState.cursorIndex,&#10;            setCursorIndex = viewModel::setCursorIndex,&#10;            resultMode = uiState.resultMode,&#10;            errorTrigger = uiState.errorTrigger,&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 12.dp)&#10;                .padding(bottom = 16.dp)&#10;                .height(48.dp)&#10;        )&#10;        ButtonGrid(&#10;            buttonLayout = if (uiState.altLayout) ScientificLayoutAlternative&#10;            else ScientificLayoutDefault,&#10;            getButtonEnabled = viewModel::getButtonEnabled,&#10;            modifier = Modifier.fillMaxWidth(),&#10;            onClick = viewModel::onButtonClicked&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun ScientificScreenPreview() {&#10;    ScientificScreen()&#10;}&#10;&#10;@Composable&#10;fun ScientificPreviousExpression(&#10;    prevSeq: List&lt;String&gt;,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;) {&#10;    val fontSize = 16.sp&#10;&#10;    if (prevSeq.isNotEmpty()) {&#10;        Surface(&#10;            modifier = modifier&#10;                .clip(MaterialTheme.shapes.large)&#10;                .clickable(onClick = onClick),&#10;            color = MaterialTheme.colorScheme.surfaceVariant,&#10;            contentColor = MaterialTheme.colorScheme.onSurfaceVariant&#10;        ) {&#10;            SequenceDisplay(&#10;                sequence = prevSeq,&#10;                fontSize = fontSize,&#10;                modifier = Modifier.padding(vertical = 2.dp)&#10;            )&#10;        }&#10;    } else Spacer(modifier)&#10;}&#10;&#10;@Preview&#10;@Composable&#10;fun ScientificPreviousExpressionPreview() {&#10;    val sequence = listOf(&quot;sin&quot;, &quot;45&quot;, &quot;°&quot;, &quot;+&quot;, &quot;12345&quot;)&#10;    ScientificPreviousExpression(&#10;        prevSeq = sequence,&#10;        onClick = {},&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 12.dp)&#10;            .height(32.dp)&#10;    )&#10;}&#10;&#10;@Composable&#10;fun ScientificInputField(&#10;    sequence: List&lt;String&gt;,&#10;    cursorIndex: Int,&#10;    setCursorIndex: (Int) -&gt; Unit,&#10;    resultMode: Boolean,&#10;    errorTrigger: Int,&#10;    modifier: Modifier = Modifier,&#10;) {&#10;    val fontSize = 32.sp&#10;&#10;    val offsetX = remember { Animatable(0f) }&#10;&#10;    val color = if (resultMode) {&#10;        MaterialTheme.colorScheme.secondary&#10;    } else {&#10;        MaterialTheme.colorScheme.primaryContainer&#10;    }&#10;    val contentColor = if (resultMode) {&#10;        MaterialTheme.colorScheme.onSecondary&#10;    } else {&#10;        MaterialTheme.colorScheme.onPrimaryContainer&#10;    }&#10;&#10;    val colorTweenSpec = tween&lt;Color&gt;(durationMillis = 400, easing = FastOutSlowInEasing)&#10;&#10;    val animatedColor by animateColorAsState(&#10;        targetValue = color, animationSpec = colorTweenSpec&#10;    )&#10;    val animatedContentColor by animateColorAsState(&#10;        targetValue = contentColor, animationSpec = colorTweenSpec&#10;    )&#10;&#10;&#10;    LaunchedEffect(errorTrigger) {&#10;        offsetX.animateTo(&#10;            targetValue = 10f,&#10;            animationSpec = tween(durationMillis = 50, easing = FastOutLinearInEasing)&#10;        )&#10;        offsetX.animateTo(&#10;            targetValue = 0f, animationSpec = spring(&#10;                dampingRatio = 0.1f, stiffness = Spring.StiffnessHigh&#10;            )&#10;        )&#10;    }&#10;&#10;    Surface(&#10;        modifier = modifier&#10;            .offset(x = offsetX.value.dp)&#10;            .clip(MaterialTheme.shapes.medium),&#10;        color = animatedColor,&#10;        contentColor = animatedContentColor&#10;    ) {&#10;        SequenceWithCursorDisplay(&#10;            sequence = sequence,&#10;            cursorIndex = cursorIndex,&#10;            setCursorIndex = setCursorIndex,&#10;            resultMode = resultMode,&#10;            fontSize = fontSize,&#10;            modifier = Modifier&#10;                .padding(vertical = 4.dp)&#10;                .fillMaxSize()&#10;        )&#10;    }&#10;}&#10;&#10;@Preview&#10;@Composable&#10;fun ScientificInputFieldPreview() {&#10;    val sequence = listOf(&quot;sin&quot;, &quot;45&quot;, &quot;°&quot;, &quot;+&quot;, &quot;12345&quot;)&#10;    ScientificInputField(&#10;        sequence = sequence,&#10;        cursorIndex = 1,&#10;        setCursorIndex = {},&#10;        resultMode = false,&#10;        errorTrigger = 0,&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 12.dp)&#10;            .height(48.dp)&#10;    )&#10;}&#10;&#10;@Composable&#10;fun SequenceDisplay(&#10;    sequence: List&lt;String&gt;,&#10;    fontSize: TextUnit,&#10;    modifier: Modifier = Modifier,&#10;) {&#10;    val scrollState = rememberScrollState()&#10;&#10;    Row(&#10;        modifier = modifier&#10;            .horizontalScroll(scrollState)&#10;            .padding(horizontal = 16.dp),&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.spacedBy(1.5.dp)&#10;    ) {&#10;        sequence.forEach { token -&gt;&#10;            Text(&#10;                text = token,&#10;                modifier = Modifier.wrapContentSize(),&#10;                fontSize = fontSize,&#10;                fontFamily = JetBrainsMono,&#10;                letterSpacing = (-0.5).sp,&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SequenceWithCursorDisplay(&#10;    sequence: List&lt;String&gt;,&#10;    cursorIndex: Int,&#10;    setCursorIndex: (Int) -&gt; Unit,&#10;    resultMode: Boolean,&#10;    fontSize: TextUnit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val scrollState = rememberScrollState()&#10;&#10;    val infiniteTransition = rememberInfiniteTransition(label = &quot;cursorBlink&quot;)&#10;    val cursorAlpha by infiniteTransition.animateFloat(&#10;        initialValue = 1f,&#10;        targetValue = 0f,&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 600, easing = FastOutLinearInEasing),&#10;            repeatMode = androidx.compose.animation.core.RepeatMode.Reverse&#10;        ), label = &quot;cursorAlpha&quot;&#10;    )&#10;&#10;    val cursorSize = DpSize(1.5.dp, fontSize.value.dp)&#10;&#10;    Row(&#10;        modifier = modifier&#10;            .horizontalScroll(scrollState)&#10;            .padding(horizontal = 8.dp),&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.spacedBy(&#10;            (-1).dp, if (resultMode) Alignment.End else Alignment.Start&#10;        )&#10;    ) {&#10;        sequence.forEachIndexed { index, text -&gt;&#10;&#10;            if (cursorIndex == index) Cursor(cursorAlpha, cursorSize)&#10;            else Spacer(Modifier.size(cursorSize))&#10;&#10;            Text(&#10;                text = text,&#10;                modifier = Modifier&#10;                    .clickable {&#10;                        setCursorIndex(index + 1)&#10;                    }&#10;                    .clip(MaterialTheme.shapes.small)&#10;                    .background(&#10;                        color = if (cursorIndex - 1 == index &amp;&amp; !resultMode) {&#10;                            MaterialTheme.colorScheme.primary.copy(alpha = 0.25f)&#10;                        } else Color.Transparent&#10;                    )&#10;                    .padding(horizontal = 4.dp)&#10;                    .padding(bottom = 4.dp)&#10;                    .wrapContentSize(),&#10;                fontSize = fontSize,&#10;                fontFamily = JetBrainsMono,&#10;                letterSpacing = (-2).sp,&#10;            )&#10;        }&#10;&#10;        if (cursorIndex == sequence.size &amp;&amp; !resultMode) Cursor(cursorAlpha, cursorSize)&#10;        else Spacer(Modifier.size(cursorSize))&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Cursor(alpha: Float, size: DpSize) {&#10;    Box(&#10;        modifier = Modifier&#10;            .size(size)&#10;            .clip(MaterialTheme.shapes.large)&#10;            .background(LocalContentColor.current.copy(alpha = alpha))&#10;    )&#10;}" />
              <option name="updatedContent" value="package com.ritel.calculator.ui.scientific&#10;&#10;import androidx.compose.animation.animateColorAsState&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.FastOutLinearInEasing&#10;import androidx.compose.animation.core.FastOutSlowInEasing&#10;import androidx.compose.animation.core.Spring&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.spring&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.horizontalScroll&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.wrapContentSize&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.material3.LocalContentColor&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.DpSize&#10;import androidx.compose.ui.unit.TextUnit&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.ritel.calculator.data.layouts.ButtonGrid&#10;import com.ritel.calculator.data.layouts.ScientificLayoutAlternative&#10;import com.ritel.calculator.data.layouts.ScientificLayoutDefault&#10;import com.ritel.calculator.ui.theme.JetBrainsMono&#10;&#10;@Composable&#10;fun ScientificScreen(modifier: Modifier = Modifier, viewModel: ScientificViewModel = viewModel()) {&#10;    val uiState by viewModel.state.collectAsState()&#10;    Column(&#10;        modifier = modifier.fillMaxSize(),&#10;        horizontalAlignment = Alignment.End,&#10;        verticalArrangement = Arrangement.Bottom&#10;    ) {&#10;        ScientificPreviousExpression(&#10;            prevSeq = uiState.prevSeq,&#10;            onClick = viewModel::onPrevSeqClicked,&#10;            modifier = Modifier&#10;                .padding(horizontal = 12.dp, vertical = 12.dp)&#10;                .height(32.dp)&#10;        )&#10;        ScientificInputField(&#10;            sequence = uiState.sequence,&#10;            cursorIndex = uiState.cursorIndex,&#10;            setCursorIndex = viewModel::setCursorIndex,&#10;            resultMode = uiState.resultMode,&#10;            errorTrigger = uiState.errorTrigger,&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 12.dp)&#10;                .padding(bottom = 16.dp)&#10;                .height(48.dp)&#10;        )&#10;        ButtonGrid(&#10;            buttonLayout = if (uiState.altLayout) ScientificLayoutAlternative&#10;            else ScientificLayoutDefault,&#10;            getButtonEnabled = viewModel::getButtonEnabled,&#10;            modifier = Modifier.fillMaxWidth(),&#10;            onClick = viewModel::onButtonClicked&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun ScientificScreenPreview() {&#10;    ScientificScreen()&#10;}&#10;&#10;@Composable&#10;fun ScientificPreviousExpression(&#10;    prevSeq: List&lt;String&gt;,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;) {&#10;    val fontSize = 16.sp&#10;&#10;    if (prevSeq.isNotEmpty()) {&#10;        Surface(&#10;            modifier = modifier&#10;                .clip(MaterialTheme.shapes.large)&#10;                .clickable(onClick = onClick),&#10;            color = MaterialTheme.colorScheme.surfaceVariant,&#10;            contentColor = MaterialTheme.colorScheme.onSurfaceVariant&#10;        ) {&#10;            SequenceDisplay(&#10;                sequence = prevSeq,&#10;                fontSize = fontSize,&#10;                modifier = Modifier.padding(vertical = 2.dp)&#10;            )&#10;        }&#10;    } else Spacer(modifier)&#10;}&#10;&#10;@Preview&#10;@Composable&#10;fun ScientificPreviousExpressionPreview() {&#10;    val sequence = listOf(&quot;sin&quot;, &quot;45&quot;, &quot;°&quot;, &quot;+&quot;, &quot;12345&quot;)&#10;    ScientificPreviousExpression(&#10;        prevSeq = sequence,&#10;        onClick = {},&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 12.dp)&#10;            .height(32.dp)&#10;    )&#10;}&#10;&#10;@Composable&#10;fun ScientificInputField(&#10;    sequence: List&lt;String&gt;,&#10;    cursorIndex: Int,&#10;    setCursorIndex: (Int) -&gt; Unit,&#10;    resultMode: Boolean,&#10;    errorTrigger: Int,&#10;    modifier: Modifier = Modifier,&#10;) {&#10;    val fontSize = 32.sp&#10;&#10;    val offsetX = remember { Animatable(0f) }&#10;&#10;    val color = if (resultMode) {&#10;        MaterialTheme.colorScheme.secondary&#10;    } else {&#10;        MaterialTheme.colorScheme.primaryContainer&#10;    }&#10;    val contentColor = if (resultMode) {&#10;        MaterialTheme.colorScheme.onSecondary&#10;    } else {&#10;        MaterialTheme.colorScheme.onPrimaryContainer&#10;    }&#10;&#10;    val colorTweenSpec = tween&lt;Color&gt;(durationMillis = 400, easing = FastOutSlowInEasing)&#10;&#10;    val animatedColor by animateColorAsState(&#10;        targetValue = color, animationSpec = colorTweenSpec&#10;    )&#10;    val animatedContentColor by animateColorAsState(&#10;        targetValue = contentColor, animationSpec = colorTweenSpec&#10;    )&#10;&#10;&#10;    LaunchedEffect(errorTrigger) {&#10;        offsetX.animateTo(&#10;            targetValue = 10f,&#10;            animationSpec = tween(durationMillis = 50, easing = FastOutLinearInEasing)&#10;        )&#10;        offsetX.animateTo(&#10;            targetValue = 0f, animationSpec = spring(&#10;                dampingRatio = 0.1f, stiffness = Spring.StiffnessHigh&#10;            )&#10;        )&#10;    }&#10;&#10;    Surface(&#10;        modifier = modifier&#10;            .offset(x = offsetX.value.dp)&#10;            .clip(MaterialTheme.shapes.medium),&#10;        color = animatedColor,&#10;        contentColor = animatedContentColor&#10;    ) {&#10;        SequenceWithCursorDisplay(&#10;            sequence = sequence,&#10;            cursorIndex = cursorIndex,&#10;            setCursorIndex = setCursorIndex,&#10;            resultMode = resultMode,&#10;            fontSize = fontSize,&#10;            modifier = Modifier&#10;                .padding(vertical = 4.dp)&#10;                .fillMaxSize()&#10;        )&#10;    }&#10;}&#10;&#10;@Preview&#10;@Composable&#10;fun ScientificInputFieldPreview() {&#10;    val sequence = listOf(&quot;sin&quot;, &quot;45&quot;, &quot;°&quot;, &quot;+&quot;, &quot;12345&quot;)&#10;    ScientificInputField(&#10;        sequence = sequence,&#10;        cursorIndex = 1,&#10;        setCursorIndex = {},&#10;        resultMode = false,&#10;        errorTrigger = 0,&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 12.dp)&#10;            .height(48.dp)&#10;    )&#10;}&#10;&#10;@Composable&#10;fun SequenceDisplay(&#10;    sequence: List&lt;String&gt;,&#10;    fontSize: TextUnit,&#10;    modifier: Modifier = Modifier,&#10;) {&#10;    val scrollState = rememberScrollState()&#10;&#10;    Row(&#10;        modifier = modifier&#10;            .horizontalScroll(scrollState)&#10;            .padding(horizontal = 16.dp),&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.spacedBy(1.5.dp)&#10;    ) {&#10;        sequence.forEach { token -&gt;&#10;            Text(&#10;                text = token,&#10;                modifier = Modifier.wrapContentSize(),&#10;                fontSize = fontSize,&#10;                fontFamily = JetBrainsMono,&#10;                letterSpacing = (-0.5).sp,&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SequenceWithCursorDisplay(&#10;    sequence: List&lt;String&gt;,&#10;    cursorIndex: Int,&#10;    setCursorIndex: (Int) -&gt; Unit,&#10;    resultMode: Boolean,&#10;    fontSize: TextUnit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val scrollState = rememberScrollState()&#10;&#10;    val infiniteTransition = rememberInfiniteTransition(label = &quot;cursorBlink&quot;)&#10;    val cursorAlpha by infiniteTransition.animateFloat(&#10;        initialValue = 1f,&#10;        targetValue = 0f,&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 600, easing = FastOutLinearInEasing),&#10;            repeatMode = androidx.compose.animation.core.RepeatMode.Reverse&#10;        ), label = &quot;cursorAlpha&quot;&#10;    )&#10;&#10;    val cursorSize = DpSize(1.5.dp, fontSize.value.dp)&#10;&#10;    Row(&#10;        modifier = modifier&#10;            .horizontalScroll(scrollState)&#10;            .padding(horizontal = 8.dp),&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.spacedBy(&#10;            (-1).dp, if (resultMode) Alignment.End else Alignment.Start&#10;        )&#10;    ) {&#10;        sequence.forEachIndexed { index, text -&gt;&#10;&#10;            if (cursorIndex == index) Cursor(cursorAlpha, cursorSize)&#10;            else Spacer(Modifier.size(cursorSize))&#10;&#10;            Text(&#10;                text = text,&#10;                modifier = Modifier&#10;                    .clickable {&#10;                        setCursorIndex(index + 1)&#10;                    }&#10;                    .clip(MaterialTheme.shapes.small)&#10;                    .background(&#10;                        color = if (cursorIndex - 1 == index &amp;&amp; !resultMode) {&#10;                            MaterialTheme.colorScheme.primary.copy(alpha = 0.25f)&#10;                        } else Color.Transparent&#10;                    )&#10;                    .padding(horizontal = 4.dp)&#10;                    .padding(bottom = 4.dp)&#10;                    .wrapContentSize(),&#10;                fontSize = fontSize,&#10;                fontFamily = JetBrainsMono,&#10;                letterSpacing = (-2).sp,&#10;            )&#10;        }&#10;&#10;        if (cursorIndex == sequence.size &amp;&amp; !resultMode) Cursor(cursorAlpha, cursorSize)&#10;        else Spacer(Modifier.size(cursorSize))&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Cursor(alpha: Float, size: DpSize) {&#10;    Box(&#10;        modifier = Modifier&#10;            .size(size)&#10;            .clip(MaterialTheme.shapes.large)&#10;            .background(LocalContentColor.current.copy(alpha = alpha))&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/ritel/calculator/ui/scientific/ScientificViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/ritel/calculator/ui/scientific/ScientificViewModel.kt" />
              <option name="originalContent" value="package com.ritel.calculator.ui.scientific&#10;&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import com.ritel.calculator.data.model.Alternate&#10;import com.ritel.calculator.data.model.Clear&#10;import com.ritel.calculator.data.model.Delete&#10;import com.ritel.calculator.data.model.Dot&#10;import com.ritel.calculator.data.model.Equals&#10;import com.ritel.calculator.data.model.ExpressionEvaluator&#10;import com.ritel.calculator.data.model.LeftArrow&#10;import com.ritel.calculator.data.model.Numeric&#10;import com.ritel.calculator.data.model.Operator&#10;import com.ritel.calculator.data.model.RightArrow&#10;import com.ritel.calculator.data.model.ScientificButton&#10;import com.ritel.calculator.data.model.ScientificFunction&#10;&#10;data class ScientificUiState(&#10;    val sequence: List&lt;String&gt; = emptyList(),&#10;    val prevSeq: List&lt;String&gt; = emptyList(),&#10;    val altLayout: Boolean = false,&#10;    val cursorIndex: Int = 0, // 0 at beginning, lastIndex+1 (=size) after first token&#10;    val selectedIndex: Int? = null, // starts from 0, null if no selection&#10;    val resultMode: Boolean = false,&#10;    val errorTrigger: Int = 0&#10;)&#10;&#10;class ScientificViewModel : ViewModel() {&#10;    var state by mutableStateOf(ScientificUiState())&#10;        private set&#10;&#10;    private val evaluator = ExpressionEvaluator()&#10;&#10;    //region Public API&#10;&#10;    fun setCursorIndex(index: Int) {&#10;        state = state.copy(cursorIndex = index.coerceIn(0, state.sequence.size))&#10;    }&#10;&#10;    fun onPrevSeqClicked() {&#10;        restorePrev()&#10;    }&#10;&#10;    fun getButtonEnabled(button: ScientificButton): Boolean {&#10;        return when (button) {&#10;            is Delete, is Clear -&gt; return state.sequence.isNotEmpty() || state.prevSeq.isNotEmpty()&#10;            is Equals -&gt; return state.sequence.isNotEmpty() &amp;&amp; !state.resultMode&#10;            else -&gt; true&#10;        }&#10;    }&#10;&#10;    fun onButtonClicked(button: ScientificButton) {&#10;        when (button) {&#10;            is Numeric, is Dot -&gt; handleNumericAndDot(button.symbol)&#10;            is Operator, is ScientificFunction -&gt; handleOperatorAndFunction(button)&#10;            is Delete -&gt; handleDelete()&#10;            is Clear -&gt; reset()&#10;            is Equals -&gt; handleEquals()&#10;            is Alternate -&gt; handleAlternate()&#10;            is LeftArrow -&gt; handleLeftArrow()&#10;            is RightArrow -&gt; handleRightArrow()&#10;        }&#10;    }&#10;    //endregion&#10;&#10;    private val cursorIndexMod: Int&#10;        get() = state.sequence.size + 1&#10;&#10;    private fun reset() {&#10;        state = ScientificUiState()&#10;    }&#10;&#10;    private fun restorePrev(toRight: Boolean = false) {&#10;        if (state.prevSeq.isEmpty()) return&#10;&#10;        state = state.copy(&#10;            sequence = state.prevSeq,&#10;            prevSeq = emptyList(),&#10;            cursorIndex = if (toRight) state.prevSeq.size else 0,&#10;            resultMode = false&#10;        )&#10;    }&#10;&#10;    private fun handleAlternate() {&#10;        state = state.copy(altLayout = !state.altLayout)&#10;    }&#10;&#10;    private fun handleLeftArrow() {&#10;        if (state.resultMode) {&#10;            restorePrev(true)&#10;            return&#10;        }&#10;        state =&#10;            state.copy(cursorIndex = ((state.cursorIndex - 1) + cursorIndexMod) % cursorIndexMod)&#10;    }&#10;&#10;    private fun handleRightArrow() {&#10;        if (state.resultMode) {&#10;            restorePrev()&#10;            return&#10;        }&#10;        state = state.copy(cursorIndex = (state.cursorIndex + 1) % cursorIndexMod)&#10;    }&#10;&#10;    private fun handleNumericAndDot(symbol: String) {&#10;        if (state.resultMode) reset()&#10;&#10;        var leftIndex = state.cursorIndex - 1&#10;&#10;        val newSequence = state.sequence.toMutableList().apply {&#10;            val left = getOrNull(leftIndex)&#10;&#10;            if (left?.toDoubleOrNull() != null) { // left is a number&#10;                set(leftIndex, left + symbol)&#10;            } else { // insert new number&#10;                leftIndex++&#10;                add(leftIndex, symbol)&#10;            }&#10;        }&#10;&#10;        state = state.copy(sequence = newSequence, cursorIndex = leftIndex + 1)&#10;    }&#10;&#10;    private fun handleOperatorAndFunction(button: ScientificButton) {&#10;        val newSequence = state.sequence.toMutableList().apply {&#10;            add(state.cursorIndex, button.symbol)&#10;        }&#10;        state = state.copy(&#10;            sequence = newSequence, cursorIndex = state.cursorIndex + 1, resultMode = false&#10;        )&#10;    }&#10;&#10;    private fun handleDelete() {&#10;        if (state.resultMode) {&#10;            restorePrev(true)&#10;            return&#10;        }&#10;        if (state.sequence.isEmpty()) return&#10;&#10;        var index = state.cursorIndex - 1&#10;&#10;        val newSequence = state.sequence.toMutableList().apply {&#10;            if (state.cursorIndex == 0) return@apply // no deletion at the beginning&#10;&#10;            val it = getOrNull(index)&#10;&#10;            if (it?.toDoubleOrNull() != null) { // it is a number&#10;                if (it.length &gt; 1) {&#10;                    set(index, it.dropLast(1))&#10;                    index++&#10;                } else {&#10;                    removeAt(index)&#10;                }&#10;            } else { // it is not a number&#10;                removeAt(index)&#10;            }&#10;        }&#10;&#10;        state = state.copy(sequence = newSequence, cursorIndex = index)&#10;    }&#10;&#10;    private fun handleEquals() {&#10;        if (state.resultMode) return&#10;&#10;        val result = evaluator.evaluate(state.sequence)&#10;&#10;        state = if (result.isSuccess) {&#10;            state.copy(&#10;                sequence = listOf(result.value?.toPlainString() ?: &quot;&quot;),&#10;                prevSeq = result.sequence,&#10;                cursorIndex = 1,&#10;                resultMode = true&#10;            )&#10;        } else {&#10;            state.copy(&#10;                cursorIndex = 0, errorTrigger = state.errorTrigger + 1&#10;            )&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.ritel.calculator.ui.scientific&#10;&#10;import androidx.lifecycle.ViewModel&#10;import com.ritel.calculator.data.model.Alternate&#10;import com.ritel.calculator.data.model.Clear&#10;import com.ritel.calculator.data.model.Delete&#10;import com.ritel.calculator.data.model.Dot&#10;import com.ritel.calculator.data.model.Equals&#10;import com.ritel.calculator.data.model.ExpressionEvaluator&#10;import com.ritel.calculator.data.model.LeftArrow&#10;import com.ritel.calculator.data.model.Numeric&#10;import com.ritel.calculator.data.model.Operator&#10;import com.ritel.calculator.data.model.RightArrow&#10;import com.ritel.calculator.data.model.ScientificButton&#10;import com.ritel.calculator.data.model.ScientificFunction&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;&#10;data class ScientificUiState(&#10;    val sequence: List&lt;String&gt; = emptyList(),&#10;    val prevSeq: List&lt;String&gt; = emptyList(),&#10;    val altLayout: Boolean = false,&#10;    val cursorIndex: Int = 0, // 0 at beginning, lastIndex+1 (=size) after first token&#10;    val selectedIndex: Int? = null, // starts from 0, null if no selection&#10;    val resultMode: Boolean = false,&#10;    val errorTrigger: Int = 0&#10;)&#10;&#10;class ScientificViewModel : ViewModel() {&#10;    private val _state = MutableStateFlow(ScientificUiState())&#10;    val state: StateFlow&lt;ScientificUiState&gt; = _state.asStateFlow()&#10;&#10;    private val evaluator = ExpressionEvaluator()&#10;&#10;    //region Public API&#10;&#10;    fun setCursorIndex(index: Int) {&#10;        _state.value = _state.value.copy(cursorIndex = index.coerceIn(0, _state.value.sequence.size))&#10;    }&#10;&#10;    fun onPrevSeqClicked() {&#10;        restorePrev()&#10;    }&#10;&#10;    fun getButtonEnabled(button: ScientificButton): Boolean {&#10;        return when (button) {&#10;            is Delete, is Clear -&gt; _state.value.sequence.isNotEmpty() || _state.value.prevSeq.isNotEmpty()&#10;            is Equals -&gt; _state.value.sequence.isNotEmpty() &amp;&amp; !_state.value.resultMode&#10;            else -&gt; true&#10;        }&#10;    }&#10;&#10;    fun onButtonClicked(button: ScientificButton) {&#10;        when (button) {&#10;            is Numeric, is Dot -&gt; handleNumericAndDot(button.symbol)&#10;            is Operator, is ScientificFunction -&gt; handleOperatorAndFunction(button)&#10;            is Delete -&gt; handleDelete()&#10;            is Clear -&gt; reset()&#10;            is Equals -&gt; handleEquals()&#10;            is Alternate -&gt; handleAlternate()&#10;            is LeftArrow -&gt; handleLeftArrow()&#10;            is RightArrow -&gt; handleRightArrow()&#10;        }&#10;    }&#10;    //endregion&#10;&#10;    private val cursorIndexMod: Int&#10;        get() = _state.value.sequence.size + 1&#10;&#10;    private fun reset() {&#10;        _state.value = ScientificUiState()&#10;    }&#10;&#10;    private fun restorePrev(toRight: Boolean = false) {&#10;        if (_state.value.prevSeq.isEmpty()) return&#10;&#10;        _state.value = _state.value.copy(&#10;            sequence = _state.value.prevSeq,&#10;            prevSeq = emptyList(),&#10;            cursorIndex = if (toRight) _state.value.prevSeq.size else 0,&#10;            resultMode = false&#10;        )&#10;    }&#10;&#10;    private fun handleAlternate() {&#10;        _state.value = _state.value.copy(altLayout = !_state.value.altLayout)&#10;    }&#10;&#10;    private fun handleLeftArrow() {&#10;        if (_state.value.resultMode) {&#10;            restorePrev(true)&#10;            return&#10;        }&#10;        _state.value =&#10;            _state.value.copy(cursorIndex = ((_state.value.cursorIndex - 1) + cursorIndexMod) % cursorIndexMod)&#10;    }&#10;&#10;    private fun handleRightArrow() {&#10;        if (_state.value.resultMode) {&#10;            restorePrev()&#10;            return&#10;        }&#10;        _state.value = _state.value.copy(cursorIndex = (_state.value.cursorIndex + 1) % cursorIndexMod)&#10;    }&#10;&#10;    private fun handleNumericAndDot(symbol: String) {&#10;        if (_state.value.resultMode) reset()&#10;&#10;        var leftIndex = _state.value.cursorIndex - 1&#10;&#10;        val newSequence = _state.value.sequence.toMutableList().apply {&#10;            val left = getOrNull(leftIndex)&#10;&#10;            if (left?.toDoubleOrNull() != null) { // left is a number&#10;                set(leftIndex, left + symbol)&#10;            } else { // insert new number&#10;                leftIndex++&#10;                add(leftIndex, symbol)&#10;            }&#10;        }&#10;&#10;        _state.value = _state.value.copy(sequence = newSequence, cursorIndex = leftIndex + 1)&#10;    }&#10;&#10;    private fun handleOperatorAndFunction(button: ScientificButton) {&#10;        val newSequence = _state.value.sequence.toMutableList().apply {&#10;            add(_state.value.cursorIndex, button.symbol)&#10;        }&#10;        _state.value = _state.value.copy(&#10;            sequence = newSequence, cursorIndex = _state.value.cursorIndex + 1, resultMode = false&#10;        )&#10;    }&#10;&#10;    private fun handleDelete() {&#10;        if (_state.value.resultMode) {&#10;            restorePrev(true)&#10;            return&#10;        }&#10;        if (_state.value.sequence.isEmpty()) return&#10;&#10;        var index = _state.value.cursorIndex - 1&#10;&#10;        val newSequence = _state.value.sequence.toMutableList().apply {&#10;            if (_state.value.cursorIndex == 0) return@apply // no deletion at the beginning&#10;&#10;            val it = getOrNull(index)&#10;&#10;            if (it?.toDoubleOrNull() != null) { // it is a number&#10;                if (it.length &gt; 1) {&#10;                    set(index, it.dropLast(1))&#10;                    index++&#10;                } else {&#10;                    removeAt(index)&#10;                }&#10;            } else { // it is not a number&#10;                removeAt(index)&#10;            }&#10;        }&#10;&#10;        _state.value = _state.value.copy(sequence = newSequence, cursorIndex = index)&#10;    }&#10;&#10;    private fun handleEquals() {&#10;        if (_state.value.resultMode) return&#10;&#10;        val result = evaluator.evaluate(_state.value.sequence)&#10;&#10;        _state.value = if (result.isSuccess) {&#10;            _state.value.copy(&#10;                sequence = listOf(result.value?.toPlainString() ?: &quot;&quot;),&#10;                prevSeq = result.sequence,&#10;                cursorIndex = 1,&#10;                resultMode = true&#10;            )&#10;        } else {&#10;            _state.value.copy(&#10;                cursorIndex = 0, errorTrigger = _state.value.errorTrigger + 1&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/ritel/calculator/ui/simple/SimpleScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/ritel/calculator/ui/simple/SimpleScreen.kt" />
              <option name="originalContent" value="package com.ritel.calculator.ui.simple&#10;&#10;import androidx.compose.animation.AnimatedContent&#10;import androidx.compose.animation.ContentTransform&#10;import androidx.compose.animation.SizeTransform&#10;import androidx.compose.animation.animateColorAsState&#10;import androidx.compose.animation.animateContentSize&#10;import androidx.compose.animation.core.FastOutSlowInEasing&#10;import androidx.compose.animation.core.LinearOutSlowInEasing&#10;import androidx.compose.animation.core.Spring&#10;import androidx.compose.animation.core.spring&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.animation.scaleIn&#10;import androidx.compose.animation.scaleOut&#10;import androidx.compose.animation.togetherWith&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.heightIn&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.widthIn&#10;import androidx.compose.foundation.layout.wrapContentHeight&#10;import androidx.compose.foundation.layout.wrapContentSize&#10;import androidx.compose.foundation.layout.wrapContentWidth&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.derivedStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableIntStateOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.TransformOrigin&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.IntSize&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.ritel.calculator.data.layouts.ButtonGrid&#10;import com.ritel.calculator.data.layouts.SimpleLayout&#10;import com.ritel.calculator.data.model.Add&#10;import com.ritel.calculator.data.model.Operator&#10;import com.ritel.calculator.data.model.Subtract&#10;&#10;@Composable&#10;fun SimpleScreen(modifier: Modifier = Modifier, viewModel: SimpleViewModel = viewModel()) {&#10;    val uiState = viewModel.state&#10;    Column(&#10;        modifier = modifier.fillMaxSize(),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Bottom&#10;    ) {&#10;        SimpleExpressionDisplay(&#10;            leftNumber = uiState.leftNumber,&#10;            operator = uiState.operator,&#10;            operatorTrigger = uiState.operatorTrigger,&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp, vertical = 10.dp),&#10;        )&#10;        SimpleCurrentNumberDisplay(&#10;            currentNumber = uiState.currentNumber,&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp)&#10;                .padding(bottom = 20.dp),&#10;            color = when {&#10;                uiState.isError -&gt; MaterialTheme.colorScheme.errorContainer&#10;                uiState.readOnly -&gt; MaterialTheme.colorScheme.secondary&#10;                else -&gt; MaterialTheme.colorScheme.primaryContainer&#10;            },&#10;            contentColor = when {&#10;                uiState.isError -&gt; MaterialTheme.colorScheme.onErrorContainer&#10;                uiState.readOnly -&gt; MaterialTheme.colorScheme.onSecondary&#10;                else -&gt; MaterialTheme.colorScheme.onPrimaryContainer&#10;            }&#10;        )&#10;        ButtonGrid(&#10;            buttonLayout = SimpleLayout,&#10;            getButtonEnabled = viewModel::getButtonEnabled,&#10;            modifier = Modifier.fillMaxWidth(),&#10;            onClick = viewModel::onButtonClicked&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun SimpleScreenPreview() {&#10;    SimpleScreen()&#10;}&#10;&#10;@Composable&#10;fun SimpleExpressionDisplay(&#10;    leftNumber: String?, operator: Operator?, operatorTrigger: Int, modifier: Modifier = Modifier&#10;) {&#10;    val height = 32.dp&#10;    val numSize = 20.sp&#10;    val opSize = 26.sp&#10;    val animationSpec = spring&lt;Float&gt;(dampingRatio = 0.5f, stiffness = 200f)&#10;&#10;    val leftNumColor = MaterialTheme.colorScheme.surfaceVariant&#10;    val leftNumContentColor = MaterialTheme.colorScheme.onSurfaceVariant&#10;    val opColor = MaterialTheme.colorScheme.tertiary&#10;    val opContentColor = MaterialTheme.colorScheme.onTertiary&#10;&#10;    Row(&#10;        modifier = modifier,&#10;        horizontalArrangement = Arrangement.SpaceBetween,&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        AnimatedContent(&#10;            targetState = leftNumber,&#10;            modifier = Modifier&#10;                .height(height)&#10;                .fillMaxWidth(0.8f),&#10;            transitionSpec = {&#10;                ContentTransform(&#10;                    scaleIn(animationSpec, transformOrigin = TransformOrigin(0f, 0.5f)) + fadeIn(),&#10;                    scaleOut(transformOrigin = TransformOrigin(0f, 0.5f)) + fadeOut(),&#10;                    sizeTransform = SizeTransform(clip = false)&#10;                )&#10;            },&#10;            label = &quot;leftNumberAnimation&quot;&#10;        ) { targetNum -&gt;&#10;            if (targetNum != null) {&#10;                Surface(&#10;                    modifier = Modifier&#10;                        .fillMaxHeight()&#10;                        .wrapContentWidth(Alignment.Start)&#10;                        .widthIn(min = height * 2),&#10;                    color = leftNumColor,&#10;                    contentColor = leftNumContentColor,&#10;                    shape = CircleShape&#10;                ) {&#10;                    Text(&#10;                        text = targetNum,&#10;                        modifier = Modifier&#10;                            .padding(horizontal = 12.dp)&#10;                            .wrapContentSize(),&#10;                        fontSize = numSize,&#10;                        fontWeight = FontWeight.Light,&#10;                        overflow = TextOverflow.Ellipsis,&#10;                        maxLines = 1&#10;                    )&#10;                }&#10;            } else {&#10;                Spacer(modifier = Modifier.fillMaxSize())&#10;            }&#10;        }&#10;&#10;        val combinedState by remember(operator?.symbol, operatorTrigger) {&#10;            derivedStateOf { Pair(operator?.symbol, operatorTrigger) }&#10;        }&#10;&#10;        AnimatedContent(&#10;            targetState = combinedState, modifier = Modifier.size(height), transitionSpec = {&#10;                (scaleIn(animationSpec) + fadeIn() togetherWith scaleOut() + fadeOut()).using(&#10;                    SizeTransform(clip = false)&#10;                )&#10;            }, label = &quot;operatorAnimation&quot;&#10;        ) { targetState -&gt;&#10;            if (targetState.first != null) {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(), // fill AnimatedContent size&#10;                    color = opColor, contentColor = opContentColor, shape = CircleShape&#10;                ) {&#10;                    Text(&#10;                        modifier = Modifier.wrapContentSize(),&#10;                        text = targetState.first!!,&#10;                        fontSize = opSize&#10;                    )&#10;                }&#10;            } else {&#10;                Spacer(modifier = Modifier.fillMaxSize())&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview&#10;@Composable&#10;fun SimpleFormulaDisplayPreview() {&#10;    var show by remember { mutableStateOf(true) }&#10;    var long by remember { mutableStateOf(false) }&#10;&#10;    val shortNumber = &quot;4&quot;&#10;    val longNumber = &quot;1234567123456712345671234567&quot;&#10;    val shortOperator = Subtract&#10;    val longOperator = Add&#10;&#10;    var leftNumber by remember { mutableStateOf&lt;String?&gt;(shortNumber) }&#10;    var operator by remember { mutableStateOf&lt;Operator?&gt;(shortOperator) }&#10;    var operatorTrigger by remember { mutableIntStateOf(0) }&#10;&#10;    fun updateValues() {&#10;        leftNumber = if (show) if (long) longNumber else shortNumber else null&#10;        operator = if (show) if (long) longOperator else shortOperator else null&#10;        operatorTrigger++&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier.padding(16.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly&#10;        ) {&#10;            Button(onClick = { show = !show; updateValues() }) {&#10;                Text(if (show) &quot;Hide&quot; else &quot;Show&quot;)&#10;            }&#10;            Button(onClick = { long = !long; updateValues() }) {&#10;                Text(if (long) &quot;Short&quot; else &quot;Long&quot;)&#10;            }&#10;        }&#10;        SimpleExpressionDisplay(leftNumber, operator, operatorTrigger, Modifier.fillMaxWidth())&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SimpleCurrentNumberDisplay(&#10;    currentNumber: String?,&#10;    modifier: Modifier = Modifier,&#10;    color: Color = MaterialTheme.colorScheme.primaryContainer,&#10;    contentColor: Color = MaterialTheme.colorScheme.onPrimaryContainer&#10;) {&#10;    val maxHeight = 180.dp&#10;    val fontSize = 66.sp&#10;    val lineHeight = 64.sp&#10;&#10;    val scrollState = rememberScrollState()&#10;&#10;    val scrollTweenSpec = tween&lt;Float&gt;(durationMillis = 200, easing = LinearOutSlowInEasing)&#10;    val colorTweenSpec = tween&lt;Color&gt;(durationMillis = 400, easing = FastOutSlowInEasing)&#10;    val animationSpec = spring&lt;IntSize&gt;(Spring.DampingRatioMediumBouncy, Spring.StiffnessLow)&#10;&#10;    val animatedColor by animateColorAsState(&#10;        targetValue = color, animationSpec = colorTweenSpec&#10;    )&#10;    val animatedContentColor by animateColorAsState(&#10;        targetValue = contentColor, animationSpec = colorTweenSpec&#10;    )&#10;&#10;    LaunchedEffect(currentNumber) {&#10;        scrollState.animateScrollTo(0, scrollTweenSpec)&#10;    }&#10;&#10;    Surface(&#10;        modifier = modifier,&#10;        shape = MaterialTheme.shapes.large,&#10;        color = animatedColor,&#10;        contentColor = animatedContentColor,&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 18.dp)&#10;                .wrapContentHeight()&#10;                .heightIn(max = maxHeight)&#10;                .verticalScroll(scrollState, reverseScrolling = true),&#10;            verticalArrangement = Arrangement.Bottom,&#10;        ) {&#10;            Box(&#10;                Modifier&#10;                    .fillMaxWidth()&#10;                    .wrapContentHeight()&#10;                    .animateContentSize(animationSpec)&#10;                    .padding(vertical = 6.dp)&#10;            ) {&#10;                Text(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .wrapContentHeight(Alignment.Top),&#10;                    text = currentNumber ?: &quot; &quot;,&#10;                    fontSize = fontSize,&#10;                    lineHeight = lineHeight,&#10;                    textAlign = TextAlign.End&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun SimpleCurrentNumberDisplayPreview() {&#10;    Column {&#10;        SimpleCurrentNumberDisplay(&quot;3.1415926535898&quot;, Modifier.fillMaxWidth())&#10;        SimpleCurrentNumberDisplay(&#10;            &quot;3.141592653589793238462643383279502884197169&quot;,&#10;            Modifier.fillMaxWidth(),&#10;            color = MaterialTheme.colorScheme.secondary,&#10;            contentColor = MaterialTheme.colorScheme.onSecondary&#10;        )&#10;        SimpleCurrentNumberDisplay(&#10;            &quot;Error&quot;,&#10;            Modifier.fillMaxWidth(),&#10;            color = MaterialTheme.colorScheme.errorContainer,&#10;            contentColor = MaterialTheme.colorScheme.onErrorContainer&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ritel.calculator.ui.simple&#10;&#10;import androidx.compose.animation.AnimatedContent&#10;import androidx.compose.animation.ContentTransform&#10;import androidx.compose.animation.SizeTransform&#10;import androidx.compose.animation.animateColorAsState&#10;import androidx.compose.animation.animateContentSize&#10;import androidx.compose.animation.core.FastOutSlowInEasing&#10;import androidx.compose.animation.core.LinearOutSlowInEasing&#10;import androidx.compose.animation.core.Spring&#10;import androidx.compose.animation.core.spring&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.animation.scaleIn&#10;import androidx.compose.animation.scaleOut&#10;import androidx.compose.animation.togetherWith&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.heightIn&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.widthIn&#10;import androidx.compose.foundation.layout.wrapContentHeight&#10;import androidx.compose.foundation.layout.wrapContentSize&#10;import androidx.compose.foundation.layout.wrapContentWidth&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.derivedStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableIntStateOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.TransformOrigin&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.IntSize&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.ritel.calculator.data.layouts.ButtonGrid&#10;import com.ritel.calculator.data.layouts.SimpleLayout&#10;import com.ritel.calculator.data.model.Add&#10;import com.ritel.calculator.data.model.Operator&#10;import com.ritel.calculator.data.model.Subtract&#10;&#10;@Composable&#10;fun SimpleScreen(modifier: Modifier = Modifier, viewModel: SimpleViewModel = viewModel()) {&#10;    val uiState by viewModel.state.collectAsState()&#10;    Column(&#10;        modifier = modifier.fillMaxSize(),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Bottom&#10;    ) {&#10;        SimpleExpressionDisplay(&#10;            leftNumber = uiState.leftNumber,&#10;            operator = uiState.operator,&#10;            operatorTrigger = uiState.operatorTrigger,&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp, vertical = 10.dp),&#10;        )&#10;        SimpleCurrentNumberDisplay(&#10;            currentNumber = uiState.currentNumber,&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp)&#10;                .padding(bottom = 20.dp),&#10;            color = when {&#10;                uiState.isError -&gt; MaterialTheme.colorScheme.errorContainer&#10;                uiState.readOnly -&gt; MaterialTheme.colorScheme.secondary&#10;                else -&gt; MaterialTheme.colorScheme.primaryContainer&#10;            },&#10;            contentColor = when {&#10;                uiState.isError -&gt; MaterialTheme.colorScheme.onErrorContainer&#10;                uiState.readOnly -&gt; MaterialTheme.colorScheme.onSecondary&#10;                else -&gt; MaterialTheme.colorScheme.onPrimaryContainer&#10;            }&#10;        )&#10;        ButtonGrid(&#10;            buttonLayout = SimpleLayout,&#10;            getButtonEnabled = viewModel::getButtonEnabled,&#10;            modifier = Modifier.fillMaxWidth(),&#10;            onClick = viewModel::onButtonClicked&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun SimpleScreenPreview() {&#10;    SimpleScreen()&#10;}&#10;&#10;@Composable&#10;fun SimpleExpressionDisplay(&#10;    leftNumber: String?, operator: Operator?, operatorTrigger: Int, modifier: Modifier = Modifier&#10;) {&#10;    val height = 32.dp&#10;    val numSize = 20.sp&#10;    val opSize = 26.sp&#10;    val animationSpec = spring&lt;Float&gt;(dampingRatio = 0.5f, stiffness = 200f)&#10;&#10;    val leftNumColor = MaterialTheme.colorScheme.surfaceVariant&#10;    val leftNumContentColor = MaterialTheme.colorScheme.onSurfaceVariant&#10;    val opColor = MaterialTheme.colorScheme.tertiary&#10;    val opContentColor = MaterialTheme.colorScheme.onTertiary&#10;&#10;    Row(&#10;        modifier = modifier,&#10;        horizontalArrangement = Arrangement.SpaceBetween,&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        AnimatedContent(&#10;            targetState = leftNumber,&#10;            modifier = Modifier&#10;                .height(height)&#10;                .fillMaxWidth(0.8f),&#10;            transitionSpec = {&#10;                ContentTransform(&#10;                    scaleIn(animationSpec, transformOrigin = TransformOrigin(0f, 0.5f)) + fadeIn(),&#10;                    scaleOut(transformOrigin = TransformOrigin(0f, 0.5f)) + fadeOut(),&#10;                    sizeTransform = SizeTransform(clip = false)&#10;                )&#10;            },&#10;            label = &quot;leftNumberAnimation&quot;&#10;        ) { targetNum -&gt;&#10;            if (targetNum != null) {&#10;                Surface(&#10;                    modifier = Modifier&#10;                        .fillMaxHeight()&#10;                        .wrapContentWidth(Alignment.Start)&#10;                        .widthIn(min = height * 2),&#10;                    color = leftNumColor,&#10;                    contentColor = leftNumContentColor,&#10;                    shape = CircleShape&#10;                ) {&#10;                    Text(&#10;                        text = targetNum,&#10;                        modifier = Modifier&#10;                            .padding(horizontal = 12.dp)&#10;                            .wrapContentSize(),&#10;                        fontSize = numSize,&#10;                        fontWeight = FontWeight.Light,&#10;                        overflow = TextOverflow.Ellipsis,&#10;                        maxLines = 1&#10;                    )&#10;                }&#10;            } else {&#10;                Spacer(modifier = Modifier.fillMaxSize())&#10;            }&#10;        }&#10;&#10;        val combinedState by remember(operator?.symbol, operatorTrigger) {&#10;            derivedStateOf { Pair(operator?.symbol, operatorTrigger) }&#10;        }&#10;&#10;        AnimatedContent(&#10;            targetState = combinedState, modifier = Modifier.size(height), transitionSpec = {&#10;                (scaleIn(animationSpec) + fadeIn() togetherWith scaleOut() + fadeOut()).using(&#10;                    SizeTransform(clip = false)&#10;                )&#10;            }, label = &quot;operatorAnimation&quot;&#10;        ) { targetState -&gt;&#10;            if (targetState.first != null) {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(), // fill AnimatedContent size&#10;                    color = opColor, contentColor = opContentColor, shape = CircleShape&#10;                ) {&#10;                    Text(&#10;                        modifier = Modifier.wrapContentSize(),&#10;                        text = targetState.first!!,&#10;                        fontSize = opSize&#10;                    )&#10;                }&#10;            } else {&#10;                Spacer(modifier = Modifier.fillMaxSize())&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview&#10;@Composable&#10;fun SimpleFormulaDisplayPreview() {&#10;    var show by remember { mutableStateOf(true) }&#10;    var long by remember { mutableStateOf(false) }&#10;&#10;    val shortNumber = &quot;4&quot;&#10;    val longNumber = &quot;1234567123456712345671234567&quot;&#10;    val shortOperator = Subtract&#10;    val longOperator = Add&#10;&#10;    var leftNumber by remember { mutableStateOf&lt;String?&gt;(shortNumber) }&#10;    var operator by remember { mutableStateOf&lt;Operator?&gt;(shortOperator) }&#10;    var operatorTrigger by remember { mutableIntStateOf(0) }&#10;&#10;    fun updateValues() {&#10;        leftNumber = if (show) if (long) longNumber else shortNumber else null&#10;        operator = if (show) if (long) longOperator else shortOperator else null&#10;        operatorTrigger++&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier.padding(16.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly&#10;        ) {&#10;            Button(onClick = { show = !show; updateValues() }) {&#10;                Text(if (show) &quot;Hide&quot; else &quot;Show&quot;)&#10;            }&#10;            Button(onClick = { long = !long; updateValues() }) {&#10;                Text(if (long) &quot;Short&quot; else &quot;Long&quot;)&#10;            }&#10;        }&#10;        SimpleExpressionDisplay(leftNumber, operator, operatorTrigger, Modifier.fillMaxWidth())&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SimpleCurrentNumberDisplay(&#10;    currentNumber: String?,&#10;    modifier: Modifier = Modifier,&#10;    color: Color = MaterialTheme.colorScheme.primaryContainer,&#10;    contentColor: Color = MaterialTheme.colorScheme.onPrimaryContainer&#10;) {&#10;    val maxHeight = 180.dp&#10;    val fontSize = 66.sp&#10;    val lineHeight = 64.sp&#10;&#10;    val scrollState = rememberScrollState()&#10;&#10;    val scrollTweenSpec = tween&lt;Float&gt;(durationMillis = 200, easing = LinearOutSlowInEasing)&#10;    val colorTweenSpec = tween&lt;Color&gt;(durationMillis = 400, easing = FastOutSlowInEasing)&#10;    val animationSpec = spring&lt;IntSize&gt;(Spring.DampingRatioMediumBouncy, Spring.StiffnessLow)&#10;&#10;    val animatedColor by animateColorAsState(&#10;        targetValue = color, animationSpec = colorTweenSpec&#10;    )&#10;    val animatedContentColor by animateColorAsState(&#10;        targetValue = contentColor, animationSpec = colorTweenSpec&#10;    )&#10;&#10;    LaunchedEffect(currentNumber) {&#10;        scrollState.animateScrollTo(0, scrollTweenSpec)&#10;    }&#10;&#10;    Surface(&#10;        modifier = modifier,&#10;        shape = MaterialTheme.shapes.large,&#10;        color = animatedColor,&#10;        contentColor = animatedContentColor,&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 18.dp)&#10;                .wrapContentHeight()&#10;                .heightIn(max = maxHeight)&#10;                .verticalScroll(scrollState, reverseScrolling = true),&#10;            verticalArrangement = Arrangement.Bottom,&#10;        ) {&#10;            Box(&#10;                Modifier&#10;                    .fillMaxWidth()&#10;                    .wrapContentHeight()&#10;                    .animateContentSize(animationSpec)&#10;                    .padding(vertical = 6.dp)&#10;            ) {&#10;                Text(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .wrapContentHeight(Alignment.Top),&#10;                    text = currentNumber ?: &quot; &quot;,&#10;                    fontSize = fontSize,&#10;                    lineHeight = lineHeight,&#10;                    textAlign = TextAlign.End&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun SimpleCurrentNumberDisplayPreview() {&#10;    Column {&#10;        SimpleCurrentNumberDisplay(&quot;3.1415926535898&quot;, Modifier.fillMaxWidth())&#10;        SimpleCurrentNumberDisplay(&#10;            &quot;3.141592653589793238462643383279502884197169&quot;,&#10;            Modifier.fillMaxWidth(),&#10;            color = MaterialTheme.colorScheme.secondary,&#10;            contentColor = MaterialTheme.colorScheme.onSecondary&#10;        )&#10;        SimpleCurrentNumberDisplay(&#10;            &quot;Error&quot;,&#10;            Modifier.fillMaxWidth(),&#10;            color = MaterialTheme.colorScheme.errorContainer,&#10;            contentColor = MaterialTheme.colorScheme.onErrorContainer&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/ritel/calculator/ui/simple/SimpleViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/ritel/calculator/ui/simple/SimpleViewModel.kt" />
              <option name="originalContent" value="package com.ritel.calculator.ui.simple&#10;&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import com.ritel.calculator.data.model.Add&#10;import com.ritel.calculator.data.model.Clear&#10;import com.ritel.calculator.data.model.Delete&#10;import com.ritel.calculator.data.model.Divide&#10;import com.ritel.calculator.data.model.Dot&#10;import com.ritel.calculator.data.model.Equals&#10;import com.ritel.calculator.data.model.Multiply&#10;import com.ritel.calculator.data.model.Numeric&#10;import com.ritel.calculator.data.model.Operator&#10;import com.ritel.calculator.data.model.Percent&#10;import com.ritel.calculator.data.model.PlusMinus&#10;import com.ritel.calculator.data.model.SimpleButton&#10;import com.ritel.calculator.data.model.SimpleFunction&#10;import com.ritel.calculator.data.model.Subtract&#10;import java.math.BigDecimal&#10;import java.math.MathContext&#10;&#10;data class SimpleUiState(&#10;    val leftNumber: String? = null,&#10;    val currentNumber: String? = null,&#10;    val operator: Operator? = null,&#10;    val readOnly: Boolean = false,&#10;    val isError: Boolean = false,&#10;    val operatorTrigger: Int = 0&#10;)&#10;&#10;class SimpleViewModel : ViewModel() {&#10;    var state by mutableStateOf(SimpleUiState())&#10;        private set&#10;    private val errorText = &quot;Error&quot;&#10;    private val mathContext = MathContext.DECIMAL128&#10;&#10;    fun getButtonEnabled(action: SimpleButton): Boolean {&#10;        return when (action) {&#10;            is Dot -&gt; state.currentNumber?.contains('.') != true&#10;            is Operator -&gt; !state.isError&#10;            is SimpleFunction -&gt; state.currentNumber != null &amp;&amp; !state.isError&#10;            is Delete -&gt; state.currentNumber != null || state.leftNumber != null&#10;            is Equals -&gt; !state.isError &amp;&amp; !state.readOnly &amp;&amp; state.leftNumber != null&#10;            else -&gt; true&#10;        }&#10;    }&#10;&#10;    fun onButtonClicked(button: SimpleButton) {&#10;        when (button) {&#10;            is Numeric -&gt; enterDigit(button.symbol)&#10;            is Dot -&gt; enterDot()&#10;            is Operator -&gt; handleOperator(button)&#10;            is SimpleFunction -&gt; handleFunction(button)&#10;            is Delete -&gt; handleDelete()&#10;            is Clear -&gt; reset()&#10;            is Equals -&gt; handleEquals()&#10;        }&#10;    }&#10;&#10;    private fun reset() {&#10;        state = SimpleUiState()&#10;    }&#10;&#10;    private fun enterDigit(symbol: String) {&#10;        if (state.readOnly) reset()&#10;        state = state.copy(&#10;            currentNumber = state.currentNumber?.takeIf { it != &quot;0&quot; }?.plus(symbol) ?: symbol&#10;        )&#10;    }&#10;&#10;    private fun enterDot() {&#10;        if (state.readOnly) reset()&#10;        state = state.copy(currentNumber = state.currentNumber.takeIf { it?.contains('.') == true }&#10;            ?: ((state.currentNumber ?: &quot;0&quot;) + &quot;.&quot;))&#10;    }&#10;&#10;    private fun handleOperator(action: Operator) {&#10;        if (state.isError) return&#10;&#10;        if (state.readOnly) state = state.copy(readOnly = false)&#10;&#10;        val (newLeft, newCurrent, newOperator) = when {&#10;            state.leftNumber == null &amp;&amp; state.currentNumber == null -&gt; Triple(&#10;                &quot;0&quot;, null, action&#10;            )&#10;&#10;            state.leftNumber == null -&gt; Triple(&#10;                state.currentNumber, null, action&#10;            )&#10;&#10;            state.currentNumber == null -&gt; Triple(&#10;                state.leftNumber, null, action&#10;            )&#10;&#10;            else -&gt; {&#10;                val result = calculate(&#10;                    state.leftNumber, state.currentNumber, state.operator&#10;                )&#10;                if (result == errorText) {&#10;                    state = state.copy(isError = true, readOnly = true)&#10;                    Triple(&#10;                        null, errorText, null&#10;                    )&#10;                } else Triple(&#10;                    result, null, action&#10;                )&#10;            }&#10;        }&#10;&#10;        state = state.copy(&#10;            leftNumber = newLeft,&#10;            currentNumber = newCurrent,&#10;            operator = newOperator,&#10;            operatorTrigger = state.operatorTrigger + 1&#10;        )&#10;    }&#10;&#10;    private fun handleFunction(action: SimpleFunction) {&#10;        when (action) {&#10;            is PlusMinus -&gt; {&#10;                state.currentNumber?.let {&#10;                    if (it != &quot;0&quot;) {&#10;                        state = state.copy(&#10;                            currentNumber = if (it.startsWith(&quot;-&quot;)) {&#10;                            it.removePrefix(&quot;-&quot;).ifEmpty { null }&#10;                        } else {&#10;                            &quot;-$it&quot;&#10;                        })&#10;                    }&#10;                }&#10;            }&#10;&#10;            is Percent -&gt; {&#10;                state = state.copy(&#10;                    currentNumber = state.currentNumber?.toBigDecimalOrNull()?.divide(&#10;                        BigDecimal.valueOf(100), mathContext&#10;                    )?.stripTrailingZeros()?.toString()&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handleDelete() {&#10;        when {&#10;            state.readOnly || state.isError -&gt; reset()&#10;&#10;            state.currentNumber == null -&gt; {&#10;                state = state.copy(&#10;                    operator = null, currentNumber = state.leftNumber, leftNumber = null&#10;                )&#10;            }&#10;&#10;            else -&gt; state = state.copy(&#10;                currentNumber = state.currentNumber!!.dropLast(1).ifEmpty { null })&#10;        }&#10;    }&#10;&#10;    private fun handleEquals() {&#10;        val result = calculate(state.leftNumber, state.currentNumber, state.operator)&#10;        if (result == errorText) state = state.copy(isError = true)&#10;&#10;        state = state.copy(&#10;            currentNumber = result, leftNumber = null, operator = null, readOnly = true&#10;        )&#10;    }&#10;&#10;    private fun calculate(&#10;        leftNumber: String?, rightNumber: String?, operator: Operator?&#10;    ): String? {&#10;        val numL = leftNumber?.toBigDecimalOrNull() ?: return rightNumber&#10;        val numR = rightNumber?.toBigDecimalOrNull() ?: return leftNumber&#10;        return operator?.let {&#10;            when (it) {&#10;                Add -&gt; numL.add(numR, mathContext)&#10;                Subtract -&gt; numL.subtract(numR, mathContext)&#10;                Multiply -&gt; numL.multiply(numR, mathContext)&#10;                Divide -&gt; {&#10;                    if (numR == BigDecimal.ZERO) {&#10;                        return errorText&#10;                    }&#10;                    numL.divide(numR, mathContext)&#10;                }&#10;            }?.stripTrailingZeros()?.toPlainString()&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.ritel.calculator.ui.simple&#10;&#10;import androidx.lifecycle.ViewModel&#10;import com.ritel.calculator.data.model.Add&#10;import com.ritel.calculator.data.model.Clear&#10;import com.ritel.calculator.data.model.Delete&#10;import com.ritel.calculator.data.model.Divide&#10;import com.ritel.calculator.data.model.Dot&#10;import com.ritel.calculator.data.model.Equals&#10;import com.ritel.calculator.data.model.Multiply&#10;import com.ritel.calculator.data.model.Numeric&#10;import com.ritel.calculator.data.model.Operator&#10;import com.ritel.calculator.data.model.Percent&#10;import com.ritel.calculator.data.model.PlusMinus&#10;import com.ritel.calculator.data.model.SimpleButton&#10;import com.ritel.calculator.data.model.SimpleFunction&#10;import com.ritel.calculator.data.model.Subtract&#10;import java.math.BigDecimal&#10;import java.math.MathContext&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;&#10;data class SimpleUiState(&#10;    val leftNumber: String? = null,&#10;    val currentNumber: String? = null,&#10;    val operator: Operator? = null,&#10;    val readOnly: Boolean = false,&#10;    val isError: Boolean = false,&#10;    val operatorTrigger: Int = 0&#10;)&#10;&#10;class SimpleViewModel : ViewModel() {&#10;    private val _state = MutableStateFlow(SimpleUiState())&#10;    val state: StateFlow&lt;SimpleUiState&gt; = _state.asStateFlow()&#10;    private val errorText = &quot;Error&quot;&#10;    private val mathContext = MathContext.DECIMAL128&#10;&#10;    fun getButtonEnabled(action: SimpleButton): Boolean {&#10;        return when (action) {&#10;            is Dot -&gt; _state.value.currentNumber?.contains('.') != true&#10;            is Operator -&gt; !_state.value.isError&#10;            is SimpleFunction -&gt; _state.value.currentNumber != null &amp;&amp; !_state.value.isError&#10;            is Delete -&gt; _state.value.currentNumber != null || _state.value.leftNumber != null&#10;            is Equals -&gt; !_state.value.isError &amp;&amp; !_state.value.readOnly &amp;&amp; _state.value.leftNumber != null&#10;            else -&gt; true&#10;        }&#10;    }&#10;&#10;    fun onButtonClicked(button: SimpleButton) {&#10;        when (button) {&#10;            is Numeric -&gt; enterDigit(button.symbol)&#10;            is Dot -&gt; enterDot()&#10;            is Operator -&gt; handleOperator(button)&#10;            is SimpleFunction -&gt; handleFunction(button)&#10;            is Delete -&gt; handleDelete()&#10;            is Clear -&gt; reset()&#10;            is Equals -&gt; handleEquals()&#10;        }&#10;    }&#10;&#10;    private fun reset() {&#10;        _state.value = SimpleUiState()&#10;    }&#10;&#10;    private fun enterDigit(symbol: String) {&#10;        if (_state.value.readOnly) reset()&#10;        _state.value = _state.value.copy(&#10;            currentNumber = _state.value.currentNumber?.takeIf { it != &quot;0&quot; }?.plus(symbol) ?: symbol&#10;        )&#10;    }&#10;&#10;    private fun enterDot() {&#10;        if (_state.value.readOnly) reset()&#10;        _state.value = _state.value.copy(currentNumber = _state.value.currentNumber.takeIf { it?.contains('.') == true }&#10;            ?: ((_state.value.currentNumber ?: &quot;0&quot;) + &quot;.&quot;))&#10;    }&#10;&#10;    private fun handleOperator(action: Operator) {&#10;        if (_state.value.isError) return&#10;&#10;        if (_state.value.readOnly) _state.value = _state.value.copy(readOnly = false)&#10;&#10;        val (newLeft, newCurrent, newOperator) = when {&#10;            _state.value.leftNumber == null &amp;&amp; _state.value.currentNumber == null -&gt; Triple(&#10;                &quot;0&quot;, null, action&#10;            )&#10;&#10;            _state.value.leftNumber == null -&gt; Triple(&#10;                _state.value.currentNumber, null, action&#10;            )&#10;&#10;            _state.value.currentNumber == null -&gt; Triple(&#10;                _state.value.leftNumber, null, action&#10;            )&#10;&#10;            else -&gt; {&#10;                val result = calculate(&#10;                    _state.value.leftNumber, _state.value.currentNumber, _state.value.operator&#10;                )&#10;                if (result == errorText) {&#10;                    _state.value = _state.value.copy(isError = true, readOnly = true)&#10;                    Triple(&#10;                        null, errorText, null&#10;                    )&#10;                } else Triple(&#10;                    result, null, action&#10;                )&#10;            }&#10;        }&#10;&#10;        _state.value = _state.value.copy(&#10;            leftNumber = newLeft,&#10;            currentNumber = newCurrent,&#10;            operator = newOperator,&#10;            operatorTrigger = _state.value.operatorTrigger + 1&#10;        )&#10;    }&#10;&#10;    private fun handleFunction(action: SimpleFunction) {&#10;        when (action) {&#10;            is PlusMinus -&gt; {&#10;                _state.value.currentNumber?.let {&#10;                    if (it != &quot;0&quot;) {&#10;                        _state.value = _state.value.copy(&#10;                            currentNumber = if (it.startsWith(&quot;-&quot;)) {&#10;                            it.removePrefix(&quot;-&quot;).ifEmpty { null }&#10;                        } else {&#10;                            &quot;-$it&quot;&#10;                        })&#10;                    }&#10;                }&#10;            }&#10;&#10;            is Percent -&gt; {&#10;                _state.value = _state.value.copy(&#10;                    currentNumber = _state.value.currentNumber?.toBigDecimalOrNull()?.divide(&#10;                        BigDecimal.valueOf(100), mathContext&#10;                    )?.stripTrailingZeros()?.toString()&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handleDelete() {&#10;        when {&#10;            _state.value.readOnly || _state.value.isError -&gt; reset()&#10;&#10;            _state.value.currentNumber == null -&gt; {&#10;                _state.value = _state.value.copy(&#10;                    operator = null, currentNumber = _state.value.leftNumber, leftNumber = null&#10;                )&#10;            }&#10;&#10;            else -&gt; _state.value = _state.value.copy(&#10;                currentNumber = _state.value.currentNumber!!.dropLast(1).ifEmpty { null })&#10;        }&#10;    }&#10;&#10;    private fun handleEquals() {&#10;        val result = calculate(_state.value.leftNumber, _state.value.currentNumber, _state.value.operator)&#10;        if (result == errorText) _state.value = _state.value.copy(isError = true)&#10;&#10;        _state.value = _state.value.copy(&#10;            currentNumber = result, leftNumber = null, operator = null, readOnly = true&#10;        )&#10;    }&#10;&#10;    private fun calculate(&#10;        leftNumber: String?, rightNumber: String?, operator: Operator?&#10;    ): String? {&#10;        val numL = leftNumber?.toBigDecimalOrNull() ?: return rightNumber&#10;        val numR = rightNumber?.toBigDecimalOrNull() ?: return leftNumber&#10;        return operator?.let {&#10;            when (it) {&#10;                Add -&gt; numL.add(numR, mathContext)&#10;                Subtract -&gt; numL.subtract(numR, mathContext)&#10;                Multiply -&gt; numL.multiply(numR, mathContext)&#10;                Divide -&gt; {&#10;                    if (numR == BigDecimal.ZERO) {&#10;                        return errorText&#10;                    }&#10;                    numL.divide(numR, mathContext)&#10;                }&#10;            }?.stripTrailingZeros()?.toPlainString()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>